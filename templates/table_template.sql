-- =====================================================
-- Template for Creating Application Tables
-- =====================================================
-- This template provides a standard structure for new tables
-- Replace TABLE_NAME with your actual table name (e.g., "Article", "Product", etc.)

-- Create the table
CREATE TABLE "public"."TABLE_NAME" (
	"id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"display_name" TEXT NOT NULL,
	"created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
	"updated_at" TIMESTAMP WITH TIME ZONE,
	-- Add your custom columns here
	-- Example:
	-- "description" TEXT,
	-- "status" BIGINT,
	-- "owner" UUID REFERENCES public.civic_os_users(id),
	CONSTRAINT "TABLE_NAME_pkey" PRIMARY KEY ("id")
);

-- Create indexes (optional - add as needed)
-- CREATE INDEX "TABLE_NAME_display_name_idx" ON "public"."TABLE_NAME" USING btree (display_name);

-- Add foreign key constraints (if any)
-- Example:
-- ALTER TABLE "public"."TABLE_NAME" ADD CONSTRAINT "TABLE_NAME_status_fkey"
--   FOREIGN KEY (status) REFERENCES "StatusTable"(id);

-- Grant basic permissions to PostgreSQL roles
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."TABLE_NAME" TO web_anon, authenticated;
GRANT USAGE ON SEQUENCE "public"."TABLE_NAME_id_seq" TO web_anon, authenticated;

-- Enable Row Level Security
ALTER TABLE "public"."TABLE_NAME" ENABLE ROW LEVEL SECURITY;

-- Create RLS Policies
CREATE POLICY "TABLE_NAME: read permission" ON "public"."TABLE_NAME"
  FOR SELECT
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'read'));

CREATE POLICY "TABLE_NAME: create permission" ON "public"."TABLE_NAME"
  FOR INSERT
  TO PUBLIC
  WITH CHECK (public.has_permission('TABLE_NAME', 'create'));

CREATE POLICY "TABLE_NAME: update permission" ON "public"."TABLE_NAME"
  FOR UPDATE
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'update'))
  WITH CHECK (public.has_permission('TABLE_NAME', 'update'));

CREATE POLICY "TABLE_NAME: delete permission" ON "public"."TABLE_NAME"
  FOR DELETE
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'delete'));

-- Apply timestamp triggers
CREATE TRIGGER set_created_at_trigger
  BEFORE INSERT ON "public"."TABLE_NAME"
  FOR EACH ROW
  EXECUTE FUNCTION public.set_created_at();

CREATE TRIGGER set_updated_at_trigger
  BEFORE INSERT OR UPDATE ON "public"."TABLE_NAME"
  FOR EACH ROW
  EXECUTE FUNCTION public.set_updated_at();

-- =====================================================
-- Full-Text Search (Optional)
-- =====================================================
-- Enable full-text search by adding a civic_os_text_search column
-- This column automatically concatenates specified fields for searching
-- Uncomment and customize the following section to enable search:

-- ALTER TABLE "public"."TABLE_NAME"
--   ADD COLUMN civic_os_text_search tsvector
--   GENERATED ALWAYS AS (
--     to_tsvector('english', coalesce(display_name, ''))
--     -- Add more fields for richer search results:
--     -- || to_tsvector('english', coalesce(description, ''))
--   ) STORED;

-- Create GIN index for fast text search
-- CREATE INDEX "TABLE_NAME_text_search_idx"
--   ON "public"."TABLE_NAME"
--   USING GIN (civic_os_text_search);

-- Configure which fields are searchable (displayed in UI)
-- UPDATE metadata.entities
--   SET search_fields = ARRAY['display_name']
--   WHERE table_name = 'TABLE_NAME';

-- =====================================================
-- Metadata Auto-Seeding
-- =====================================================
-- Automatically populate metadata from database schema views
-- This reads from schema_entities and schema_properties views and
-- calls the upsert RPC functions to seed the metadata tables.

-- Auto-seed entity metadata from schema_entities view
DO $$
DECLARE
  entity_rec RECORD;
  entity_cursor CURSOR FOR
    SELECT table_name, display_name
    FROM public.schema_entities
    WHERE table_name = 'TABLE_NAME';
BEGIN
  OPEN entity_cursor;
  LOOP
    FETCH entity_cursor INTO entity_rec;
    EXIT WHEN NOT FOUND;

    -- Call upsert function with defaults
    -- Customize display_name, description, and sort_order as needed
    PERFORM public.upsert_entity_metadata(
      p_table_name := entity_rec.table_name,
      p_display_name := entity_rec.display_name,  -- Default from view
      p_description := NULL,  -- Add custom description here if desired
      p_sort_order := 100  -- Customize sort order as needed
    );
  END LOOP;
  CLOSE entity_cursor;
END $$;

-- Auto-seed property metadata from schema_properties view
DO $$
DECLARE
  prop_rec RECORD;
  prop_cursor CURSOR FOR
    SELECT table_name, column_name, display_name, sort_order
    FROM public.schema_properties
    WHERE table_name = 'TABLE_NAME'
      AND column_name NOT IN ('id', 'created_at', 'updated_at');  -- Skip system fields
BEGIN
  OPEN prop_cursor;
  LOOP
    FETCH prop_cursor INTO prop_rec;
    EXIT WHEN NOT FOUND;

    -- Call upsert function with defaults
    -- Customize display_name, description, sort_order, and visibility as needed
    PERFORM public.upsert_property_metadata(
      p_table_name := prop_rec.table_name,
      p_column_name := prop_rec.column_name,
      p_display_name := prop_rec.display_name,  -- Default from view (auto-generated from column name)
      p_description := NULL,  -- Add custom description here if desired
      p_sort_order := prop_rec.sort_order,  -- Default from view (ordinal position)
      p_column_width := NULL,  -- Not yet implemented in UI
      p_show_on_list := true,  -- Show in list view
      p_show_on_create := true,  -- Show in create form
      p_show_on_edit := true,  -- Show in edit form
      p_show_on_detail := true  -- Show in detail view
    );
  END LOOP;
  CLOSE prop_cursor;
END $$;

-- Manual override examples (optional - uncomment and customize):
-- Override entity display name and add description
-- SELECT public.upsert_entity_metadata(
--   p_table_name := 'TABLE_NAME',
--   p_display_name := 'Custom Display Name',
--   p_description := 'Detailed description of this entity',
--   p_sort_order := 50
-- );

-- Override specific property settings
-- SELECT public.upsert_property_metadata(
--   p_table_name := 'TABLE_NAME',
--   p_column_name := 'display_name',
--   p_display_name := 'Name',
--   p_description := 'The name of this item',
--   p_sort_order := 1,
--   p_column_width := NULL,
--   p_show_on_list := true,
--   p_show_on_create := true,
--   p_show_on_edit := true,
--   p_show_on_detail := true
-- );

-- =====================================================
-- Permissions Setup
-- =====================================================
-- Create RBAC permissions for this table
-- Add this section to your permissions script

-- Create permissions for this table
INSERT INTO metadata.permissions (table_name, permission) VALUES
  ('TABLE_NAME', 'read'),
  ('TABLE_NAME', 'create'),
  ('TABLE_NAME', 'update'),
  ('TABLE_NAME', 'delete')
ON CONFLICT (table_name, permission) DO NOTHING;

-- Grant all permissions to admin role
INSERT INTO metadata.permission_roles (permission_id, role_id)
SELECT p.id, r.id
FROM metadata.permissions p
CROSS JOIN metadata.roles r
WHERE p.table_name = 'TABLE_NAME'
  AND r.display_name = 'admin'
ON CONFLICT DO NOTHING;

-- Example: Grant read permission to all users (including anonymous)
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission = 'read'
--   AND r.display_name IN ('anonymous', 'user', 'editor', 'admin')
-- ON CONFLICT DO NOTHING;

-- Example: Grant create/update to authenticated users
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission IN ('create', 'update')
--   AND r.display_name IN ('user', 'editor', 'admin')
-- ON CONFLICT DO NOTHING;

-- Example: Grant delete to editors only
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission = 'delete'
--   AND r.display_name IN ('editor', 'admin')
-- ON CONFLICT DO NOTHING;

-- Notify PostgREST to reload schema cache
NOTIFY pgrst, 'reload schema';
