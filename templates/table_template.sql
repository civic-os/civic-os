-- =====================================================
-- Template for Creating Application Tables
-- =====================================================
-- This template provides a standard structure for new tables
-- Replace TABLE_NAME with your actual table name (e.g., "Article", "Product", etc.)

-- Create the table
CREATE TABLE "public"."TABLE_NAME" (
	"id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"display_name" TEXT NOT NULL,
	"created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
	"updated_at" TIMESTAMP WITH TIME ZONE,
	-- Add your custom columns here
	-- Example:
	-- "description" TEXT,
	-- "status" BIGINT,
	-- "owner" UUID REFERENCES public.civic_os_users(id),
	CONSTRAINT "TABLE_NAME_pkey" PRIMARY KEY ("id")
);

-- Create indexes (optional - add as needed)
-- CREATE INDEX "TABLE_NAME_display_name_idx" ON "public"."TABLE_NAME" USING btree (display_name);

-- Add foreign key constraints (if any)
-- Example:
-- ALTER TABLE "public"."TABLE_NAME" ADD CONSTRAINT "TABLE_NAME_status_fkey"
--   FOREIGN KEY (status) REFERENCES "StatusTable"(id);

-- Grant basic permissions to PostgreSQL roles
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."TABLE_NAME" TO web_anon, authenticated;
GRANT USAGE ON SEQUENCE "public"."TABLE_NAME_id_seq" TO web_anon, authenticated;

-- Enable Row Level Security
ALTER TABLE "public"."TABLE_NAME" ENABLE ROW LEVEL SECURITY;

-- Create RLS Policies
CREATE POLICY "TABLE_NAME: read permission" ON "public"."TABLE_NAME"
  FOR SELECT
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'read'));

CREATE POLICY "TABLE_NAME: create permission" ON "public"."TABLE_NAME"
  FOR INSERT
  TO PUBLIC
  WITH CHECK (public.has_permission('TABLE_NAME', 'create'));

CREATE POLICY "TABLE_NAME: update permission" ON "public"."TABLE_NAME"
  FOR UPDATE
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'update'))
  WITH CHECK (public.has_permission('TABLE_NAME', 'update'));

CREATE POLICY "TABLE_NAME: delete permission" ON "public"."TABLE_NAME"
  FOR DELETE
  TO PUBLIC
  USING (public.has_permission('TABLE_NAME', 'delete'));

-- Apply timestamp triggers
CREATE TRIGGER set_created_at_trigger
  BEFORE INSERT ON "public"."TABLE_NAME"
  FOR EACH ROW
  EXECUTE FUNCTION public.set_created_at();

CREATE TRIGGER set_updated_at_trigger
  BEFORE INSERT OR UPDATE ON "public"."TABLE_NAME"
  FOR EACH ROW
  EXECUTE FUNCTION public.set_updated_at();

-- =====================================================
-- Metadata and Permissions Setup
-- =====================================================
-- Add this section to your sample data script or run separately

-- Optional: Add custom display name and description to metadata
-- INSERT INTO metadata.entities (table_name, display_name, description, sort_order) VALUES
--   ('TABLE_NAME', 'Display Name', 'Description of this entity', 100)
-- ON CONFLICT (table_name) DO NOTHING;

-- Optional: Customize column labels and ordering
-- INSERT INTO metadata.properties (table_name, column_name, display_name, description, sort_order) VALUES
--   ('TABLE_NAME', 'display_name', 'Name', 'The name of this item', 1)
-- ON CONFLICT (table_name, column_name) DO NOTHING;

-- Create permissions for this table
-- INSERT INTO metadata.permissions (table_name, permission) VALUES
--   ('TABLE_NAME', 'read'),
--   ('TABLE_NAME', 'create'),
--   ('TABLE_NAME', 'update'),
--   ('TABLE_NAME', 'delete')
-- ON CONFLICT (table_name, permission) DO NOTHING;

-- Grant read permission to anonymous users
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission = 'read'
--   AND r.display_name = 'anonymous'
-- ON CONFLICT DO NOTHING;

-- Grant create/update to authenticated users
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission IN ('create', 'update')
--   AND r.display_name IN ('user', 'editor', 'admin')
-- ON CONFLICT DO NOTHING;

-- Grant delete to editors and admins only
-- INSERT INTO metadata.permission_roles (permission_id, role_id)
-- SELECT p.id, r.id
-- FROM metadata.permissions p
-- CROSS JOIN metadata.roles r
-- WHERE p.table_name = 'TABLE_NAME'
--   AND p.permission = 'delete'
--   AND r.display_name IN ('editor', 'admin')
-- ON CONFLICT DO NOTHING;

-- Notify PostgREST to reload schema cache
NOTIFY pgrst, 'reload schema';
